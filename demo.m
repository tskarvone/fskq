%%%%%%%%%
%%%
%%% Demo for using different functions
%%%
%%% Toni Karvonen, 2017
%%%
%%%%%%%%%

%% Addpath
  addpath('fskq/')

%% Constructing fully symmetric sets (FSS)
  
  % To construct a fully symmetric set, one needs to specify
  % its generator. Elements that are zero need not be given
  % if one also gives the dimension.
  u = [2; 1]; % Genarator vector (must be a column vector)
  d = 3;      % We're in dimension 3
  U = fss(u, d);
  
  % An equivalent way of constructing the above FSS is
  u = [2; 1; 0];
  U = fss(u);
  
  % Display the FSS
  figure
  plot3(U(1,:), U(2,:), U(3,:), 'o')
  title('A fully symmetric set in 3D')
  grid on
  
  % If there are multiple FSSs that need to be constructed,
  % the function fss_gen can be used.
  u1 = [2; 1; 0];
  u2 = [0.5; 0.1; 3];
  us = [u1 u2];
  Us = fss_gen(us); % This is a cell array, i.e. the FSSs are
                    % Us{1} and Us{2}
  
  % The function fss_numel can be used to compute the number
  % elements in a fully symmetric set given its generator
  % vector (and possible the dimension)
  u = [2; 1];
  d = 3;
  numel_u = fss_numel(u, d);
  % Or
  u = [2; 1; 0];
  numel_u = fss_numel(u);
  
%% Doing kernel quadrature
  
  % For any kernel quadrature rule, one needs to specify the kernel
  % and the kernel mean. There is full support only for isotropic kernels
  % at the moment. Such kernels can be given manually:
  d       = 8; % Dimension                                
  l       = 1; % Length-scale       
  % Kernel, given as a function of the distance of the arguments              
  k       = @(r) exp(-r.^2/(2*l^2));
  % Kernel mean and its integral (here the integration measure is Gaussian)
  kmean   = @(x) (l^2 / (1+l^2))^(d/2) * ...
                   exp( -norm(x)^2 /(2*(1+l^2)) );
  Ikmean  = (l^2/(2+l^2))^(d/2);
  % Or via KQ_KERNEL function:
  [k kmean Ikmean] = kq_kernel('gauss', l, d, 'normal');
  
  % Weights of a kernel quadrature rule can be computed with KQW:
  X = randn(d, 100); % The node set
  w = kqw(X, k, kmean);
  
  % Kernel quadrature approximation of an integral can be computed
  % using the weights
  f = @(x) norm(x);     % Integrand
  Y = funceval(f, X);   % FUNCEVAL can be used for point-wise evaluation of functions.
                        % The result is a row vector of function evaluations.
  Q = w' * Y';          % Multiply each function evaluation by the corresponding weight and sum
  % Or with the KQ function that also returns the WCE:
  [Q, wce, w] = kq(Y, X, k, kmean, Ikmean);

%% Doing fully symmetric kernel quadrature

  % Fully symmetric kernel quadrature (FSKQ) is done with the functions KQW_FSS and
  % KQ_FSS
  
  % KQW_FSS computes the distinct weights, one for each fully symmetric set
  % The fully symmetric sets need to be given in a cell array, as generated by FSS_GEN
  d = 3;
  l = 0.2;
  [k kmean Ikmean] = kq_kernel('gauss', l, d, 'normal');
  us = abs(randn(d, 8)); % Eight random generators in dimension 4
  Us = fss_gen(us);
  wr = kqw_fss(Us, k, kmean); % The distinct weights
  % We can verify that the weights are computed correctly
  % NOTE: this sometimes fails if the full kernel matrix becomes too badly conditioned
  X = cell2mat(Us);
  w = kqw(X, k, kmean);
  abs(sort(wr,'ascend') - uniquetol(w, 1e-3)) % Compute difference in distinct weights
  
  % Similarly KQ, the function KQ_FSS can be used to do the whole integration procedure
  f = @(x) norm(x);    % Integrand
  Y = funceval(f, X);  % The evaluations need to be in the same order as the FSSs
  [Q, wce, w] = kq_fss(Y, Us, k, kmean, Ikmean);
  
%% Doing sparse grid kernel quadrature

  % Sparse grids require specifying the univariate point sets X. This is done via CC_SEQ
  % (Clenshaw-Curtis nodes) or GH_SEQ (Gauss-Hermite nodes)
  q  = 8; % Sparse grid level
  XS = cc_seq(q);
  % XS is no a cell array whose each cell contains the additional positive points for that
  % 1D point set. That is, following notation in the article,
  % XS{i} = { x \in X^i \setminus X^{i-1} : x >= 0 }
  
  % The function SPARSE_GENS takes such a cell array of 1D points and the dimension and 
  % determines the generators needed to construct the sparse grid
  d = 2;
  us = sparse_gens(XS, d);
  % The FSSs can be generated now with FSS_GEN
  Us = fss_gen(us);
  X = cell2mat(Us);
  % Plot
  figure
  plot(X(1,:), X(2,:), '.')
  title('A sparse grid in 2D')
  % After this the FSKQ functions KQW_FSS and KQ_FSS can be used to compute the weights and
  % integral approximations
